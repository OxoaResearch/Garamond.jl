#!/bin/julia

#############################################
# Garamond script for CLI client operations #
#############################################
module GaramondCLIClient

using Sockets
using ArgParse
using Logging
using JSON

import ArgParse: parse_item


# Support for parsing to Symbol for the ArgParse package
function ArgParse.parse_item(::Type{Symbol}, x::AbstractString)
    return Symbol(x)
end


# Function that parses Garamond's unix-socket client arguments
function get_unix_socket_client_arguments(args::Vector{String})
	s = ArgParseSettings()
	@add_arg_table s begin
        "query"
            help = "the search query"
            arg_type = String
            default = ""
        "--log-level"
            help = "logging level"
            default = "warn"
        "--unix-socket", "-u"
            help = "UNIX socket for data communication"
            default = ""
            arg_type = String
        "--pretty"
            help = "output is a pretty print of the results"
            action = :store_true
        "--max-matches"
            help = "maximum results to return"
            arg_type = Int
            default = 10
        "--search-method"
            help = "type of match done during search"
            arg_type = Symbol
            default = :exact
        "--max-suggestions"
            help = "How many suggestions to return for each mismatched query term"
            arg_type = Int
            default = 0
        "--kill", "-k"
            help = "Kill the search engine server"
            action = :store_true
	end
	return parse_args(args,s)
end


# Function that performs a simple search i.e. sends data to
# a socket, reads from the socket and outputs to STDOUT
function iosearch(connection, request, pretty=false)
    # Checks
    if isopen(connection)
        println(connection, request)
        @debug ">>> Request sent."
        response = readline(connection, keep=true)
        @debug "<<< Search results received."
    else
        @error "Connection is closed."
    end
    # Deconstruct response
    data = deconstruct_response(response)
    if pretty
        jr = JSON.parse(data)  # builds a Dict
        # Print search results in a way similar to that
        # of the web client (`garw` web page)
        println("Elapsed search time: $(jr["etime"])s.")
        println("Found $(jr["n_matches"]) results in $(jr["n_corpora_match"])" *
                " corpora (out of a total of $(jr["n_corpora"])):")
        for (id, crps_matches) in jr["matches"]
            !isempty(crps_matches) && println("$id")
            for (score, metadata) in crps_matches
                # format: score ~ name by author, publisher (year)
                println("\t$(score) ~ \"$(metadata["name"])\" "*
                        "by $(metadata["author"]), "*
                        "[$(metadata["publisher"])] "*
                        "($(metadata["published_year"]))")
            end
        end
        # Print suggestions
        suggestions = jr["suggestions"]["d"]
        ns = length(suggestions)
        ns > 0 && println("$ns suggestions:")
        for (keyword, suggest) in suggestions
            print("  \"$keyword\": ")
            println("$(join(map(x->x[2], suggest), ", "))")
        end
    else
        println(stdout, data)
    end
    return nothing
end


# Function that constructs a search server request (can be a
# search request or a command) from a set of arguments
# that come usually from parsed client input arguments
function construct_request(query, max_matches, search_method,
                           max_suggestions, pretty, kill)
    # Check wether the query is actually a query or another command
    if kill
        op = "kill"
    else
        op = "search"
    end
    what_to_return = ifelse(pretty, "json-data", "json-index")
    return JSON.json(
            Dict("operation" => op,
                 "query" => query,
                 "max_matches" => max_matches,
                 "search_method" => search_method,
                 "max_suggestions" => max_suggestions,
                 "what_to_return" => what_to_return
                )
           )
end


# Deconstruct response is a pass through right now
deconstruct_response(response) = response


########################
# Main client function #
########################
Base.@ccallable function julia_main(ARGS::Vector{String})::Cint
    # Parse command line arguments
    args = get_unix_socket_client_arguments(ARGS)

    # Logging
    log_levels = Dict("debug" => Logging.Debug,
                      "info" => Logging.Info,
                      "warning" => Logging.Warn,
                      "error" => Logging.Error)
    logger = ConsoleLogger(stdout,
                get(log_levels, args["log-level"], Logging.Info))
    global_logger(logger)

    # Start client
    @debug "~ GARAMOND~ (unix-socket client)"
    unixsocket = args["unix-socket"]
    if issocket(unixsocket)
        conn = connect(unixsocket)

        # Construct Garamond request
        if isempty(args["query"]) && !args["kill"]
            @warn "Empty query, nothing to search. Exiting..."
        else
            request = construct_request(
                args["query"],
                args["max-matches"], args["search-method"],
                args["max-suggestions"],
                args["pretty"], args["kill"])

            # Search
            iosearch(conn, request, args["pretty"])
        end

        # Close connection and exit
        close(conn)
    else
        @warn "$unixsocket is not a proper UNIX socket. Exiting..."
    end
    return 0
end


##############
# Run client #
##############
julia_main(ARGS)

end  # GaramondCLIClient
